forge:
  replicas: 1
  revisionHistoryLimit: 10
  localPostgresql: true
  localValkey: true
  https: true
  projectNamespace: flowforge
  projectSelector:
    role: projects
  projectDeploymentTolerations: []
  projectNetworkPolicy:
    enabled: false
  projectIngressAnnotations: {}
  projectPodSecurityContext:
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
  managementSelector:
    role: management
  telemetry:
    enabled: true
    backend:
      prometheus:
        enabled: false
  labels: {}
  podLabels: {}
  broker:
    enabled: false
    image: iegomez/mosquitto-go-auth
    revisionHistoryLimit: null
    teamBroker:
      enabled: false
    createMetricsUser: false
    podSecurityContext:
      runAsUser: 1000
      runAsGroup: 1000
      fsGroup: 1000
      seccompProfile:
        type: RuntimeDefault
    livenessProbe:
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 15
      successThreshold: 1
      failureThreshold: 5
    readinessProbe:
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 15
      successThreshold: 1
      failureThreshold: 3
    containerSecurityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
    labels: {}
    podLabels: {}
    tolerations: []
    ingress.annotations: {}
  logging:
    level: info
    http: info

  persistentStorage:
    enabled: false

  fileStore:
    enabled: false
    revisionHistoryLimit: null
    type: localfs
    quota: 104857600
    options:
      root: var/root
    context:
      type: sequelize
      quota: 1048576
      options:
        type: postgres
    podSecurityContext:
      runAsUser: 1000
      runAsGroup: 1000
      fsGroup: 1000
      seccompProfile:
        type: RuntimeDefault
    containerSecurityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
    serviceAccount:
      create: false
      name: flowfuse-file-sa
      automountServiceAccountToken: true
      annotations: {}
    automountServiceAccountToken: false
    labels: {}
    podLabels: {}
    tolerations: []
    telemetry:
      backend:
        prometheus:
          enabled: false

  support:
    enabled: false

  rate_limits:
    enabled: false
    global: true
    max: 1000
    timeWindow: 60000

  domain: ""
  entryPoint: ""
  environment: {}
  image: ""
  registry: ""

  initContainers:
    config:
      image:
        registry: ""
    waitForLocalDb:
      image:
        registry: ""

  contentSecurityPolicy:
    enabled: false
    reportOnly: false

  podSecurityContext:
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL

  livenessProbe:
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3
  readinessProbe:
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3

  tolerations: []

  priorityClassName: ""

  logPassthrough: false
  customHostname:
    enabled: false
    ingressAnnotations: {}

  assistant: {}

  expert: {}

  tables:
    enabled: false

  service:
    type: ClusterIP

postgresql:
  image:
    registry: "docker.io"
    repository: bitnamilegacy/postgresql
    tag: "14.10.0-debian-11-r30"
  auth:
    postgresPassword: Moomiet0
    username: forge
    password: Zai1Wied
    database: flowforge
    fileStoreDatabase: ff-context

ingress:
  annotations: {}
  className: ""

editors:
  serviceAccount:
    create: true
    annotations: {}
    name: editors

broker:
  image: emqx:5
  revisionHistoryLimit: null
  storageClassName: ''
  listenersServiceTemplate: {}
  dashboardServiceTemplate: {}
  existingSecret: ''
  config: |
    authentication = [
      {
        backend = http
        body = {
          clientId = "${clientid}"
          username = "${username}"
          password = "${password}"
        }
        enable = true
        connect_timeout = "15s"
        enable_pipelining = 1
        headers {
          content-type = "application/json"
        }
        mechanism = password_based
        method = post
        pool_size = 8
        request_timeout = "15s"
        ssl {
          enable = false
        }
        url = "http://forge.{{ .Release.Namespace }}/api/comms/v2/auth"
      }
    ]
    mqtt {
      max_packet_size: 128MB
      max_awaiting_rel = infinity
    }
    authorization {
      cache {
        enable = true
        excludes = []
        max_size = 32
        ttl = "1m"
      }
      deny_action = ignore
      no_match = allow
      sources = [
        {
          enable = true
          enable_pipelining = 1
          connect_timeout = "15s"
          request_timeout = "30s"
          pool_size = 8
          body {
            action = "${action}"
            topic = "${topic}"
            username = "${username}"
          }
          headers {
            content-type = "application/json"
          }
          method = post
          type = http
          ssl {
            enable = false
          }
          url = "http://forge.{{ .Release.Namespace }}/api/comms/v2/acls"
        }
      ]
    }
    listeners {
      tcp {
        default {
          bind = "0.0.0.0:1883"
          access_rules = [
            "allow all"
          ]
          enable = true
          enable_authn = true
          mountpoint = "${client_attrs.team}"
          max_connections = infinity
          acceptors = 16
          proxy_protocol = false
          proxy_protocol_timeout = 3s
          tcp_options {
            backlog = 1024
            send_timeout = 15s
            recbuf = 2KB
            sndbuf = 4KB
            buffer = 4KB
            high_watermark = 1MB
            nodelay = true
            reuseaddr = true
            keepalive = "none"
          }
        }
      }
      ssl {
        default {
          enable = false
        }
      }
      wss {
        default {
          enable = false
        }
      }
      ws {
        default {
          bind = "0.0.0.0:8080"
          access_rules = [
            "allow all"
          ]
          enable = true
          enable_authn = true
          mountpoint = "${client_attrs.team}"
          max_connections = infinity
          proxy_protocol = false
          proxy_protocol_timeout = 3s
          tcp_options {
            backlog = 1024
            send_timeout = 15s
            recbuf = 2KB
            sndbuf = 4KB
            buffer = 4KB
            high_watermark = 1MB
            nodelay = true
            reuseaddr = true
            keepalive = "none"
          }
          websocket {
            mqtt_path = "/"
            allow_origin_absence = true
            check_origin_enable = false
            fail_if_no_subprotocol = true
            supported_subprotocols = "mqtt, mqtt-v3, mqtt-v3.1.1 mqtt-v5"
            mqtt_piggyback = multiple
            compress = false
            idle_timeout = 7200s
            max_frame_size = infinity
            proxy_address_header = "x-forwarded-for"
            proxy_port_header = "x-forwarded-port"
          }
        }
      }
    }
  monitoring:
    emqxExporter:
      enabled: false
      revisionHistoryLimit: null
      image:
        registry: ""
        repository: emqx/emqx-exporter
        tag: "0.2"
  service:
    type: ClusterIP

npmRegistry:
  enabled: false
  revisionHistoryLimit: null
  image:
    registry: ""
    repository: "flowfuse/npm-registry"
    tag: "latest"
  podSecurityContext: {}

valkey:
  replicaCount: 1

  persistence:
    enabled: false
    size: 20Gi

  resources:
    requests:
      memory: 512Mi
      cpu: 250m
    limits:
      memory: 1Gi
      cpu: 500m

  auth:
    enabled: false

  metrics:
    enabled: true
    serviceMonitor:
      enabled: true

  config:
    maxMemory: 800mb
    maxMemoryPolicy: allkeys-lru
    save: 3600 1 300 100 60 10000
